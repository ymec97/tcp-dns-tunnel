
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>server module &#8212; TCP TUNNEL OVER DNS 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-server">
<span id="server-module"></span><h1>server module<a class="headerlink" href="#module-server" title="Permalink to this heading">¶</a></h1>
<p>Module for the server side of the tunnel</p>
<dl class="simple">
<dt>This module runs 2 threads:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>listen_dns - This thread is listening on the for incoming dns packets.</dt><dd><p>For every dns packet that is part of the tunnel extract the tcp packet alter it so the server
will get the response (change the src addresses) and send the altered packet.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>listen_tcp - This thread is listening for incoming tcp packets, if the packet is part of an active client session</dt><dd><p>wrapp the tcp with dns response and send it back to the client.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="server.TunnelServer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">server.</span></span><span class="sig-name descname"><span class="pre">TunnelServer</span></span><a class="headerlink" href="#server.TunnelServer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class that encapsulate the server side tunnel</p>
<dl class="simple">
<dt>Attributes:</dt><dd><p>source_client:
local_machine:
dns_bpf_filter: filter that used inorder to catch only dns packet that the server is the destination
tcp_bpf_filter: filter that used inorder to catch tcp packets that the server is the destination
active_session_mapping:</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="server.TunnelServer.TUNNEL_INTERFACE">
<span class="sig-name descname"><span class="pre">TUNNEL_INTERFACE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'tun0'</span></em><a class="headerlink" href="#server.TunnelServer.TUNNEL_INTERFACE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="server.TunnelServer.add_packet_to_active_session">
<span class="sig-name descname"><span class="pre">add_packet_to_active_session</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tcp_packet</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#server.TunnelServer.add_packet_to_active_session" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the source port to identify tcp responses that are destined to the tunnel by their dest port</p>
<p>When a packet is returned from a target server, we check if the destination port is for
an active session, if so it’s for the client side of the tunnel,
otherwise it’s for the dns tunnel server itself</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="server.TunnelServer.alter_packet_origin">
<span class="sig-name descname"><span class="pre">alter_packet_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">packet</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#server.TunnelServer.alter_packet_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the packet src addresses (mac and ip)</p>
<p>This function is used when incoming dns packet is handled.
Inorder to properly send the client tcp packet we need to change the src ip and mac to be our, and update the
checksum accordingly.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>packet: the dns packet that contains the tcp packet</p>
</dd>
<dt>Returns:</dt><dd><p>packet: the tcp packet that is ready to sent</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="server.TunnelServer.extract_wrapped_packet_bytes">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">extract_wrapped_packet_bytes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">packet</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#server.TunnelServer.extract_wrapped_packet_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the actual data from the dns packet</p>
<dl class="simple">
<dt>Args:</dt><dd><p>packet: the dns packet we use as tunnel</p>
</dd>
<dt>Returns:</dt><dd><p>the actual bytes of the tcp packet</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="server.TunnelServer.get_resp_data_from_active_sessions">
<span class="sig-name descname"><span class="pre">get_resp_data_from_active_sessions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#server.TunnelServer.get_resp_data_from_active_sessions" title="Permalink to this definition">¶</a></dt>
<dd><p>Get packet data for a response packet with the tunnel’s client information.</p>
<p>In the future will be client specific for multy client support</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="server.TunnelServer.handle_dns_query">
<span class="sig-name descname"><span class="pre">handle_dns_query</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dns_packet</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#server.TunnelServer.handle_dns_query" title="Permalink to this definition">¶</a></dt>
<dd><p>Send tcp packet from the client to the wanted destination.</p>
<p>For every dns packet only handle it if it is part of the tunnel (has the tunnel magic)
If the packet is part of the tunnel extract from it the actual tcp packet, alter the packet to it looked as if
the server is the one sending it.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>dns_packet: Incoming tcp packet</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="server.TunnelServer.handle_real_packet_to_server">
<span class="sig-name descname"><span class="pre">handle_real_packet_to_server</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">packet</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#server.TunnelServer.handle_real_packet_to_server" title="Permalink to this definition">¶</a></dt>
<dd><p>Send real dns packets (not tunnel ones) to the system to handle.</p>
<p>Inorder to prevent automatic response on tunnel related dns requests all the incoming dns packets are
transferred to the localhost. If we get real dns request (and not one from the tunnel) pass it back to the
system to handle.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>packet: Incoming dns packet</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="server.TunnelServer.handle_tcp_response">
<span class="sig-name descname"><span class="pre">handle_tcp_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">packet</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#server.TunnelServer.handle_tcp_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Send tcp response back to the client.</p>
<p>For every tcp packet only handle it if it is part of an active client session.
If the tcp is part of an active session then create DNS response packet tht encapsulates the tcp response
and send ot to the appropriate client.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>packet: Incoming tcp packet</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="server.TunnelServer.is_for_active_session">
<span class="sig-name descname"><span class="pre">is_for_active_session</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">packet</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#server.TunnelServer.is_for_active_session" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure the tcp packet is part of an active client session</p>
<dl class="simple">
<dt>Parameters:</dt><dd><p>packet: Incoming tcp packet</p>
</dd>
<dt>Returns:</dt><dd><p>bool: whether the packet is part of active session</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="server.TunnelServer.our_dns_packet">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">our_dns_packet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">packet</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#server.TunnelServer.our_dns_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure the dns packet is from the client</p>
<dl class="simple">
<dt>Parameters:</dt><dd><p>packet: Incoming dns packet</p>
</dd>
<dt>Returns:</dt><dd><p>bool: whether the packet is from the client</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="server.TunnelServer.serve">
<span class="sig-name descname"><span class="pre">serve</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#server.TunnelServer.serve" title="Permalink to this definition">¶</a></dt>
<dd><p>The server side tunnel</p>
<p>Runs _listen_dns and _listen_tcp as threads.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="server.TunnelServer.tunnel_response_tcp_packet">
<span class="sig-name descname"><span class="pre">tunnel_response_tcp_packet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">packet</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#server.TunnelServer.tunnel_response_tcp_packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure the packet is tcp packet and is part of an active client session</p>
<dl class="simple">
<dt>Parameters:</dt><dd><p>packet: Incoming packet</p>
</dd>
<dt>Returns:</dt><dd><p>bool: whether the packet is tcp and part of active session</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="server.main">
<span class="sig-prename descclassname"><span class="pre">server.</span></span><span class="sig-name descname"><span class="pre">main</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#server.main" title="Permalink to this definition">¶</a></dt>
<dd><p>Main entry point of the server side tunnel.</p>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">TCP TUNNEL OVER DNS</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Yarden Cohen, Shani Yosef.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/server.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>